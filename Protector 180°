#include <Servo.h>

// ---------- SEGMENT & DIGIT CONNECTION ----------
const int segPins[7] = {2, 3, 4, 5, 6, 7, 8};  
// A, B, C, D, E, F, G

const int digPins[4] = {10, 11, 12, 13};  
// Digit select pins (common cathode)

// ---------- POTENTIOMETER + SERVO ----------
const int POT_PIN   = A0;
const int SERVO_PIN = 9;   // Servo signal on D9

Servo myservo;

// ---------- DIGIT PATTERNS (common cathode) ----------
const byte digitPattern[10] = {
  0b00111111, // 0
  0b00000110, // 1
  0b01011011, // 2
  0b01001111, // 3
  0b01100110, // 4
  0b01101101, // 5
  0b01111101, // 6
  0b00000111, // 7
  0b01111111, // 8
  0b01101111  // 9
};

// ---------- Variables ----------
int digits[4] = {0, 0, 0, 0};
int currentDigit = 0;

unsigned long lastRefresh = 0;
const int refreshRate = 2;   // 2 ms per digit â†’ 125 Hz refresh for all 4 digits

unsigned long lastUpdate = 0;
const int updateRate = 25;   // update servo+digits every 25 ms

// ---------- Helpers ----------
int smoothAnalog(int pin) {
  long sum = 0;
  for (int i = 0; i < 5; i++) {
    sum += analogRead(pin);
  }
  return sum / 5;  // average of 5 samples
}

void displayDigit(int digitIndex, int value) {
  // Turn off all digits first
  for (int i = 0; i < 4; i++) digitalWrite(digPins[i], HIGH);

  if (value >= 0 && value <= 9) {
    byte pat = digitPattern[value];
    for (int s = 0; s < 7; s++)
      digitalWrite(segPins[s], (pat >> s) & 0x01 ? HIGH : LOW);
  } else {
    for (int s = 0; s < 7; s++) digitalWrite(segPins[s], LOW); // blank
  }

  // Enable digit
  digitalWrite(digPins[digitIndex], LOW);
}

void setup() {
  for (int i = 0; i < 7; i++) pinMode(segPins[i], OUTPUT);
  for (int i = 0; i < 4; i++) pinMode(digPins[i], OUTPUT);

  myservo.attach(SERVO_PIN);
}

void loop() {
  // --- 1. Update servo + digits (slow loop) ---
  if (millis() - lastUpdate >= updateRate) {
    lastUpdate = millis();

    int raw = smoothAnalog(POT_PIN);

    // floating point mapping for accuracy
    float angleF = (raw / 1023.0) * 180.0;
    int angle = (int)(angleF + 0.5); // round to nearest integer

    if (angle > 180) angle = 180;
    if (angle < 0) angle = 0;

    myservo.write(angle);

    // prepare digits
    digits[3] = -1;                // blank last digit
    digits[2] = angle % 10;        // ones
    digits[1] = (angle / 10) % 10; // tens
    digits[0] = (angle >= 100) ? (angle / 100) % 10 : -1; // hundreds or blank
  }

  // --- 2. Refresh display continuously ---
  if (millis() - lastRefresh >= refreshRate) {
    lastRefresh = millis();
    displayDigit(currentDigit, digits[currentDigit]);
    currentDigit = (currentDigit + 1) % 4;
  }
}
